=head1 NAME

gedafe-sql - Database Structure for Gedafe

=head1 SYNOPSIS

Gedafe is a generic web front-end to PostgreSQL. Generic means in this
context that Gedafe does not know anything about the structure or
contents of the database it is presenting.

The idea is that Gedafe looks at a database and presents it on the
web.  Because Gedafe is no AI it relies on certain rules for the
database structure and naming rules.

It is also important to note that Gedafe itself does not impose any
restrictions on to what a user can do with a database. All consistency
and permission rules must be checked on the back-end side of the
database. PostgreSQL offers excellent support for this kind of checks
through referential integrity constraints, rules, triggers and stored
procedures. The advantage of this approach is that data integrity does
not depend on the usage of a certain front-end, but is enforced for
all possible interactions with the database short of manipulation of
the database structure and rules themselves. The disadvantage of this
approach is that it imposes a large load on the database server,
especially on insert and update queries.

=head1 NAMING RULES

=head2 Unique Field Names

Each field in the user defined tables must have a unique name. This
simplifies writing queries because there is no need for fully
qualified field naming. The unique names must be built by appending
the field name to the table name with an underscore in between.

Example:

 CREATE TABLE customer (
   customer_name TEXT, 
   customer_age  INT,
   customer_address TEXT);

Gedafe currently assumes that you follow this rule. If you don't things will
not work as expected. We are planning to relaxe this requirement in the
future (nevertheless it will remain "good practice" :-))

=head2 Non Speaking Unique ID

Each table defines a B<unique>, B<non speaking>, B<numeric>
I<table>B<_id> field.  It is best to use an auto-increment counter for
this field. The field I<table>B<_id> can be used when a table is
referenced from another table.

If a unique ID for human consumption is required, it must be
called I<table>B<_hid>.

Often the I<table>B<_hid> will be presented to the user of the
database, while internally the I<table>B<_id> is used as
reference.

Example:

 CREATE TABLE customer (
   customer_id SERIAL NOT NULL PRIMARY KEY,
   customer_hid TEXT UNIQUE,
   customer_name TEXT, 
   customer_age INT,
   customer_address TEXT);

The reason we are requiering unique nonspeaking ids is twofold. First gedafe
need some way to uniquely identify each database record (*_list, *_combo,
...) and second it is good design practice to use nonspeaking keys. In any
event, if you need speaking keys, just use a *_hid on top of the *_id, and
you are all set.

You will also note, that we are imposing some magic names, like *_list,
*_combo, *_id, *_hid, ... we chose todo this, because we think it is simpler
to name fields apropriately, than to write up another table telling gedafe
about which field has what role in the database.
 
=head2 Table and Field Naming

For the benefit of a friendly presentation, each field and table in
the database can have a description. Descriptions are added using the
B<COMMENT> command.

Example:

 COMMENT ON TABLE customer IS 'Customers';
 COMMENT ON COLUMN customer.customer_hid 'C Number';

=head1 VIEWS FOR PRESENTATION

=head2 Presentation View

When listing the contents of a table, the front-end uses "C<SELECT *
FROM> I<table>" unless there is a view called I<table>C<_list>
in which case the records are pulled from this view.  The reason for
this is that tables containing references to tuples from other tables
might not be very presentable. The users don't want to see B<*_id>
fields. They want the corresponding B<*_HID> field from the referenced
table or maybe even more. Another reason for creating a B<*_list> view
may be that you do not want to present ALL records or fields to a
user.

The first column of a B<*_list> view must always be the B<*_id> field
from original table. This column does not get displayed if there is a
B<*_hid> column as well. The other column names should match their
original counter part unless they contain calculated data (this is not
enforced; however, no new comments for the fields of the view must be
given if this convention is followed as described below).

Example:

 CREATE VIEW absence_list AS
   SELECT absence_id, pers_hid, absty_hid, absence_start, 
          absence_end, absence_days, absence_desc
   FROM absence,absty,pers 
   WHERE absence_pers=pers_id 
         AND absence_absty=absty_id 
         AND NOT pers_virt;

A B<*_list> view can contain rows which do not correspond to rows in
the original table. These rows must have the value B<NULL> in the
B<*_id> column. 'Editing' the data of such a row from the front-end
causes a row to be inserted into the database. Defaults for the new
row are taken from the edited NULL-row.

You may want to pre-sort the contents of a view. Unfortunately,
PostgreSQL does not allow to ORDER views. As a work-around, you can
create a column in your view called B<meta_sort> which the front-end
will use to sort the contents of the view as long as there are no
other sorting instructions present.

You can set a COMMENT for each field of a B<*_list> view, this comment
will then be taken as column head. If you do not define a special
comment, but the name of the list field is identical to the field in
its parent table, then the COMMENT from the parent table field will be
used. The same is true if the list field name matches the name of any
other commented table field in the database.

=head2 The Combo-box

When editing fields that are a reference to a row in another table it is
useful to have some help in filling out the field. Best is to provide a
list of all possible values. The widget used to present this information to
the user is called combo-box. In order to make this possible, each table
which gets referenced by another table must be accompanied by a special
view called I<table>B<*_combo>. This view must have two columns one called
B<id> and one called B<text>. The B<id> column contains the id of the
referenced record. You can select the view to be taken for a certain field
instead of the one chosen automatically be Gedafe by explicitely using the
'idcombo', 'hidcombo' or 'combo' widget attribute in meta_fields like explained
in L<EDIT WIDGETS>.

If you want to order the contents of the combo-box, then this can be
done using an extra B<meta_sort> column as explained below. By
default, combo-boxes get sorted by the contents of their B<text>
column.

Example:
 
 CREATE VIEW gender_combo AS
    SELECT gender_hid  AS id, 
           gender_name AS text 
    FROM gender;

 CREATE VIEW proj_combo AS
    SELECT proj_id                               AS id, 
           proj_name || ', ' || pers_hid         AS text,
           proj_popularity(proj_id) || proj_name AS meta_sort 
    FROM proj, pers 
    WHERE proj_pers=pers_id and proj_active=true;

The last example uses a custom function proj_popularity() which
calculates a project popularity value which is then used as sort key
in order to get the most popular projects first in the combo
box. Again, this is not computationally cheap.

=head1 META INFORMATION

=head2 The B<meta_tables> Table

For some tables you may want to provide additional information to
optimize their presentation in the front-end.

 CREATE TABLE meta_tables (
    -- Table Name
    meta_tables_table       NAME NOT NULL PRIMARY KEY,
    -- Attribute
    meta_tables_attribute   TEXT NOT NULL,
    -- Value
    meta_tables_value       TEXT
 );

This additional information is specified for a given table in
attribute/value pairs. The B<meta_tables> table must be created in
your database, even if you don't use it. The following attributes are
currently defined:

=over 2

=item filterfirst

If a table tends to be big, it is possible to suggest a field to filter on
before a table is displayed. This is done by specifying the field name as
value for this attribute. If you have a _list view for that long table, the
filterfirst must be set on the _list table and one of its attributes.
Because views will not contain any information about which table a certain
attribute potentially references, this information must be specified in the
meta_fields table accordingly.

Example:

I have this view called task_list which I want to filterfirst on the pack_id
attribut. The combo I want to see comes from the pack table.

 INSERT INTO meta_tables VALUES ('task_list', 'filterfirst','my_pack');
 INSERT INTO meta_fields VALUES ('task_list', 'my_pack','reference','pack');

Note, that if pack had a _hid attribute, gedafe would figure it out and use
this instead of the standard _id, assuming you would prefer _hid over _id.

=item hide

If the value of this attribute is set to '1', the table won't be shown
by the front-end.

=back

=head2 The B<meta_fields> table

For most fields is is possible to determine a presentation mode from
the data type of the field. For some fields this is not possible and
additional information must be provided. This is done through the
B<meta_fields> table. Every database must have a B<meta_fields> table.
It may be empty if no special information must be provided.

 CREATE TABLE meta_fields (
    -- Table Name
    meta_fields_table       NAME    NOT NULL,
    -- Field Name
    meta_fields_field       NAME    NOT NULL,
    -- Attribute
    meta_fields_attribute   TEXT    NOT NULL,
    -- Value
    meta_fields_value       TEXT
 );

As for meta_tables, the additional information is specified in
attribute/value pairs for the field in question. The following
attributes are defined:

=over 2

=item align

In listings of table content, this field overrides the alignment of
the column. The contents of this field is put directly in the alignment
section of the <td> tag. It is therefor good practice to put double
quotes around left,right and center. e.g.: "LEFT" "RIGHT" "CENTER".

When not specified the alignment defaults to "LEFT" unless
the column type is in [numeric,date,time,timestamp,int4,int8,float8].
In that case, the alignment is "RIGHT" NOWRAP.
 
=item copy

If set to '1', while adding entries to a table, the data for this
field will be copied from one form to the next.

=item hide_list

Do not show this field in the list (table) view.

=item markup

If set to '1', the data in this field will be scanned for strings which
resemble special web objects (currently implemented: e-mail addresses
and http URLs).  If found, these strings will be replaced with appropriate
HTML markup (template variable DATA will be altered in element 'td').

=item sortfunc

If you have a column which contains names like 'von Burg' or 'di
Alfredi' and you want the column sorted by the second word, you can
create a function which converts the name into a string suitable for
sorting. The name of this function must be given as value for this
attribute. Note, however, that there is a heavy performance penalty,
as this function must be called for each row of the table. A less
costly approach during selects is the use of a meta_sort field as
described above (the penalty there is again in inserts and updates).

=item widget

Override Gedafe's automatically selected widget (element in the edit form to
enter the value of a field). A widget definition is written like this:

 widgetname(param1=val1,param2=val2,...)

If no parameters are specified, then the parens can be omitted. See chapter
L<EDIT WIDGETS> for a description of all available widgets and the available
parameters.

=back

=head1 EDIT WIDGETS

=over 8

=item readonly

read-only text

=item text

Text field. The optional argument I<size> specifies the width of the text field
in characters (default: 20).

=item area

Use a C<TEXTAREA> widget for this field, such that longer amounts of text
can be entered.

=item date

The I<date> widget on date columns generates a pulldown list to enter
dates. The I<from> and I<to> parameters specify the the range for the year
list.

=item idcombo

Text-entry, followed by a combo-box to select (text-entry has higher priority).
The mandatory parameter I<combo> specifies the name of the view to use to fetch
the contents of the combo-box. See L<The Combo-box> for a description of how to
write views for combo-boxes.

=item hidcombo

Like C<idcombo>, but the text field references the C<hid> in the referenced
table. Additionally to I<combo>, the mandatory parameter I<ref> specifies the
name of the referenced table (so that the C<hid> can be converted to C<id>).

=item combo

Like C<idcombo> but just the combo-box without text entry.

=item isearch

I<isearch> as a widget for a column that references another table specifies
a interactive record selecting applet. The applet is designed to replace
comboboxes on tables with many records where the combobox would become 
impracticaly large.

Because the isearch applet searches in all columns of the referenced table 
it ignores the table*_combo views, instead it use the original table or ,if 
present, the table*_list view. Also note that the values of bytea columns 
are translated to yield only the filename instead of the raw content.

The isearch applet will only download a search resultset that is smaller 
than 20kb to make sure that long waits are avoided. The progress of the 
download is displayed with a blue bar progress indicator. 
When the resultset is too large the user has the option to narrow down the
search criteria by entering more characters to column search values and 
then rescanning the resultspace by pressing the the 'scan' button. 
Once a resultset is loaded entering characters to column search values
immeadiately (interactivly) selects matching records.

Please also note that for this applet to work you need to have a browser 
that supports java, javascript and liveconnect. 
(Mozilla, Netscape and IE will do fine)

The isearch applet can be placed on a custom location on your web-server.
Placing it in the cgi-bin directory of your server can lead to the
web-server trying to execute the java archive instead of serving it.
Make sure that the 'isearch' variable in your cgi-script is set to point
to the web address of the isearch.jar java archive.

=back

=head1 REPORTS

Analog to the B<*_list> views you can create as many B<*_rep> views as
you want, the only condition being that their names end in B<_rep>. This
can be used for simple reporting. For more complex reports you may
want to check out our B<PearlReports> module.

Example:

 CREATE VIEW absence_rep AS
    SELECT to_char(absence_start,'YYYY') as year,
           pers_hid, absty_hid, sum(absence_days) as days
    FROM absence, pers, absty
    WHERE absence_pers=pers_id 
          AND absence_absty=absty_id AND NOT pers_virt
    GROUP BY pers_hid, absty_hid, year;

=head1 ACCESS RIGHTS

Gedafe reads the access rights of the user to determine if a table can be
accessed (SELECT must be granted), if a record can be added (INSERT must be
granted) and if a record can be edited/deleted (UPDATE must be granted). Be
careful about access rights in the database. They determine what users can
do.  To manage access rights more easily, it is sensible to grant rights to
groups and add users to the groups according to the rights you want them to
have.

=head1 BINARY LARGE OBJECTS

Columns of the BYTEA type get a special treatment in Gedafe. These columns
are used to store files in the database. Users can upload and download the 
file with their browser. To use these files in other software please keep
in mind that the perl BYTEA encoding is not standard. The directory src/bytea
provides information for using this data with Perl and PHP.

=head1 COPYRIGHT

Copyright (c) 2000-2003 ETH Zurich, All rights reserved.

=head1 LICENSE

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=head1 AUTHOR

S<Tobias Oetiker E<lt>oetiker@ee.ethz.chE<gt>>,
S<David Schweikert E<lt>dws@ee.ethz.chE<gt>>,
S<Fritz Zaucker E<lt>zaucker@ee.ethz.chE<gt>>,
S<Adi Fairbank E<lt>adi@adiraj.orgE<gt>>,
S<Freek Zindel E<lt>freek@zindel.nlE<gt>>
